// Copyright 2017 Workiva Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import 'dart:html';

import 'package:meta/meta.dart';
import 'package:platform_detect/platform_detect.dart';
import 'package:platform_detect/src/support.dart';

/// The CSS class that will be used to indicate that [decorateRootNodeWithPlatformClasses]
/// has already been invoked for a given root node.
const String _decorationCompleteClassName = 'pd--decorated';

/// The CSS class that will be used to represent the current [browser].
final String _browserClassName =
    browser.className ?? nameToClassName(browser.name);

/// The CSS class that will be used to represent the current [operatingSystem].
final String _osClassName = nameToClassName(operatingSystem.name);

/// The string that will be prepended to the CSS class generated by [getPlatformClasses]
/// for [_browserClassName].
const String _browserClassPrefix = 'ua-';

/// The string that will be prepended to the CSS class generated by [getPlatformClasses]
/// for [_osClassName].
const String _osClassPrefix = 'os-';

/// The string that will be prepended to the CSS class generated by [getPlatformClasses]
/// for [_osClassName].
const String _versionRangeClassPrefix = 'lt-';

/// The string that will be prepended to the CSS class generated by [getPlatformClasses]
/// for [Feature.name] if [Feature.isSupported] is `false`.
const String _featureSupportNegationClassPrefix = 'no-';

/// The first major release after the current one.
@visibleForTesting
final int minVersionRange = browser.version.major + 1;

/// The number of major releases above [minVersionRange]
/// that [_getBrowserVersionClasses] should produce CSS classes for.
@visibleForTesting
const int maxVersionRange = 2;

String _getBrowserVersionClasses() {
  var majorVersion = browser.version.major;
  var classes = [
    _browserClassPrefix + _browserClassName + majorVersion.toString()
  ];

  for (var i = minVersionRange; i < minVersionRange + maxVersionRange; i++) {
    classes.add(
        '$_browserClassPrefix$_versionRangeClassPrefix$_browserClassName$i');
  }

  return _listToClassNameString(classes);
}

String _getFeatureSupportClasses(List<Feature> features) {
  var classes = [];

  for (var i = 0; i < features.length; i++) {
    var feature = features[i];

    classes.add(feature.isSupported
        ? feature.name
        : '${_featureSupportNegationClassPrefix}${feature.name}');
  }

  return _listToClassNameString(classes);
}

/// Utility fn that takes a list of [classes] and returns a space-separated string for
/// use within the `class` attribute on the `<html>` element that gets injected by
/// [decorateRootNodeWithPlatformClasses].
String _listToClassNameString(List<String> classes) {
  var classesStr = '';

  for (var i = 0; i < classes.length; i++) {
    if (classesStr.isEmpty) {
      classesStr = classes[i];
    } else {
      classesStr += ' ${classes[i]}';
    }
  }

  return classesStr;
}

/// Convert white-space within the given [name] to dashes, and convert it to lowercase
/// for standardized CSS class formatting.
@visibleForTesting
String nameToClassName(String name) {
  return name.replaceAll(' ', '-').toLowerCase();
}

/// Whether the given [rootNode] has already had it's CSS classes set via [decorateRootNodeWithPlatformClasses].
bool nodeHasBeenDecorated(Element rootNode) =>
    rootNode.classes.contains(_decorationCompleteClassName);

/// Generates CSS classes based on the current [browser], [operatingSystem] and optionally,
/// [features] that your app may need conditional styling for in addition to the
/// [defaultFeatureCssClassDecorators] that will have CSS classes present by default.
String getPlatformClasses({List<Feature> features, List<String> decorators}) {
  decorators ??= [];

  if (features != null && features.isNotEmpty) {
    features.addAll(defaultFeatureCssClassDecorators);
  } else {
    features = defaultFeatureCssClassDecorators;
  }

  decorators.add(_browserClassPrefix + _browserClassName);
  decorators.add(_getBrowserVersionClasses());
  decorators.add(_osClassPrefix + _osClassName);
  decorators.add(_getFeatureSupportClasses(features));
  decorators.add(_decorationCompleteClassName);

  return _listToClassNameString(decorators);
}

/// Appends CSS classes generated by [getPlatformClasses] to the specified [rootNode].
///
/// By default, [rootNode] is [document.documentElement].
void decorateRootNodeWithPlatformClasses(
    {List<Feature> features, Element rootNode, Function callback}) {
  if (document == null) return;

  rootNode ??= document.documentElement;

  if (rootNode != null && !nodeHasBeenDecorated(rootNode)) {
    var existingClasses = rootNode.classes.toList();

    rootNode.className =
        getPlatformClasses(features: features, decorators: existingClasses);

    if (callback != null) callback();
  }
}
