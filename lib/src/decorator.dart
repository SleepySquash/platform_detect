// Copyright 2017 Workiva Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import 'dart:html';

import 'package:meta/meta.dart';
import 'package:platform_detect/platform_detect.dart';
import 'package:platform_detect/src/support.dart';

/// The CSS class that will be used to indicate that [decorateRootNodeWithPlatformClasses]
/// has already been invoked for a given root node.
const String _decorationCompleteClassName = 'pd--decorated';

/// The CSS class that will be used to represent the current [browser].
final String _browserClassName =
    browser.className ?? nameToClassName(browser.name);

/// The CSS class that will be used to represent the current [operatingSystem].
final String _osClassName = nameToClassName(operatingSystem.name);

/// The string that will be prepended to the CSS class generated by [getPlatformClasses]
/// for [_browserClassName].
const String _browserClassPrefix = 'ua-';

/// The string that will be prepended to the CSS class generated by [getPlatformClasses]
/// for [_osClassName].
const String _osClassPrefix = 'os-';

/// The string that will be prepended to the CSS class generated by [getPlatformClasses]
/// for [_osClassName].
const String _versionRangeClassPrefix = 'lt-';

/// The string that will be prepended to the CSS class generated by [getPlatformClasses]
/// for [Feature.name] if [Feature.isSupported] is `false`.
@visibleForTesting
const String featureSupportNegationClassPrefix = 'no-';

/// The first major release after the current one.
@visibleForTesting
final int nextVersion = browser.version.major + 1;

/// The number of major releases above [nextVersion]
/// that [_getBrowserVersionClasses] should produce CSS classes for.
@visibleForTesting
const int decoratedNextVersionCount = 2;

String _getBrowserVersionClasses() {
  var majorVersion = browser.version.major;
  var classes = [
    _browserClassPrefix + _browserClassName + majorVersion.toString()
  ];

  for (var i = nextVersion; i < nextVersion + decoratedNextVersionCount; i++) {
    classes.add(
        '$_browserClassPrefix$_versionRangeClassPrefix$_browserClassName$i');
  }

  return _listToClassNameString(classes);
}

/// Utility fn that returns the CSS classes that are analogous to the provided list of [features].
@visibleForTesting
String getFeatureSupportClasses(List<Feature> features) {
  var classes = features.map((feature) => feature.isSupported
      ? feature.name
      : '$featureSupportNegationClassPrefix${feature.name}');

  return _listToClassNameString(classes.toList());
}

/// Utility fn that looks for [Feature]s within [consumerFeatures] that are not present
/// within [defaultFeatureCssClassDecorators].
///
/// If any unique [Feature]s are found, they will be returned along with [defaultFeatureCssClassDecorators].
///
/// Ensures that the feature-based CSS classes returned from [getPlatformClasses] does not contain duplicates.
List<Feature> _getAllSupportedFeatures(List<Feature> consumerFeatures) {
  // Short-circuit if no `consumerFeatures` are found
  if (consumerFeatures == null || consumerFeatures.isEmpty)
    return defaultFeatureCssClassDecorators;

  List<Feature> allSupportedFeatures =
      new List.from(defaultFeatureCssClassDecorators);
  var defaultFeaturesFoundInConsumerFeaturesList = 0;

  for (var i = 0; i < consumerFeatures.length; i++) {
    var consumerFeature = consumerFeatures[i];

    // Only check the default features list for the next `feature`
    // if all possible "matches" have not already been made.
    if (defaultFeaturesFoundInConsumerFeaturesList <=
        defaultFeatureCssClassDecorators.length) {
      if (defaultFeatureCssClassDecorators.contains(consumerFeature)) {
        defaultFeaturesFoundInConsumerFeaturesList++;
        // Don't add this feature since we've already accounted for it when we
        // initialized the value of `allSupportedFeatures`.
        continue;
      } else {
        // The `consumerFeature` was not found within `defaultFeatureCssClassDecorators`.
        allSupportedFeatures.add(consumerFeature);
      }
    } else {
      // All default features have already been located in the provided `features` list,
      // so we can safely add to `nonDefaultConsumerFeatures` without checking for its
      // presence within `defaultFeatureCssClassDecorators`.
      allSupportedFeatures.add(consumerFeature);
    }
  }

  return allSupportedFeatures;
}

/// Utility fn that takes a list of [classes] and returns a space-separated string for
/// use within the `class` attribute on the `<html>` element that gets injected by
/// [decorateRootNodeWithPlatformClasses].
String _listToClassNameString(List<String> classes) =>
    classes.where((classStr) => classStr.isNotEmpty).join(' ');

/// Convert white-space within the given [name] to dashes, and convert it to lowercase
/// for standardized CSS class formatting.
@visibleForTesting
String nameToClassName(String name) {
  return name.replaceAll(' ', '-').toLowerCase();
}

/// Whether the given [rootNode] has already had it's CSS classes set via [decorateRootNodeWithPlatformClasses].
bool nodeHasBeenDecorated(Element rootNode) =>
    rootNode.classes.contains(_decorationCompleteClassName);

/// Generates CSS classes based on the current [browser], [operatingSystem] and optionally,
/// [features] that your app may need conditional styling for in addition to the
/// [defaultFeatureCssClassDecorators] that will have CSS classes present by default.
String getPlatformClasses(
    {List<Feature> features, List<String> existingClasses: const []}) {
  var classes = []
    ..addAll(existingClasses)
    ..add(_browserClassPrefix + _browserClassName)
    ..add(_getBrowserVersionClasses())
    ..add(_osClassPrefix + _osClassName)
    ..add(getFeatureSupportClasses(_getAllSupportedFeatures(features)))
    ..add(_decorationCompleteClassName);

  return _listToClassNameString(classes);
}

/// Appends CSS classes generated by [getPlatformClasses] to the specified [rootNode].
///
/// By default, [rootNode] is [document.documentElement].
void decorateRootNodeWithPlatformClasses(
    {List<Feature> features, Element rootNode, callback()}) {
  rootNode ??= document.documentElement;

  if (rootNode != null && !nodeHasBeenDecorated(rootNode)) {
    var existingClasses = rootNode.classes.toList();

    rootNode.className = getPlatformClasses(
        features: features, existingClasses: existingClasses);

    if (callback != null) callback();
  }
}
